<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merry Christmas: Mobile Perfect</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/ScrollTrigger.min.js"></script>

    <style>
        /* === 1. ÂÖ®Â±ÄÈáçÁΩÆ === */
        * { box-sizing: border-box; }
        body { 
            margin: 0; overflow-x: hidden; 
            font-family: 'Times New Roman', serif; 
            height: 100vh; width: 100vw;
            user-select: none;
            background: #000;
            /* Èò≤Ê≠¢ iOS Ê©°ÁöÆÁ≠ãÊïàÊûúÂΩ±Âìç‰ΩìÈ™å */
            overscroll-behavior: none; 
        }

        /* === 2. Ê†∏ÂøÉ‰øÆÂ§çÔºöCanvas ÂÖÅËÆ∏ÂûÇÁõ¥ÊªöÂä® === */
        canvas { 
            position: fixed; top: 0; left: 0; z-index: 1; outline: none; 
            /* „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç„ÄëÂÖÅËÆ∏ÂûÇÁõ¥ÊñπÂêëÁöÑÊªöÂä®Á©øÈÄèÔºåËß£ÂÜ≥ÊâãÊú∫Êªë‰∏çÂä®ÁöÑÈóÆÈ¢ò */
            touch-action: pan-y !important; 
        }

        /* Áã¨Á´ãËÉåÊôØÂ±Ç */
        #fixed-background {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 40%, #1a2530 0%, #090a0f 60%, #000000 100%);
            z-index: -10;
        }
        #bg-canvas { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: -5; pointer-events: none; 
        }

        /* === 3. Â∞ÅÈù¢ === */
        #landing-page {
            position: fixed; top: 0; left: 0; width: 100%; height: 100vh;
            background: rgba(0,0,0,0.92); z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; transition: opacity 1.5s;
        }
        #landing-title {
            color: #d4af37; letter-spacing: 3px; text-shadow: 0 2px 10px rgba(212,175,55,0.3);
            font-size: 1.5rem; margin-bottom: 30px; text-align: center; opacity: 0.9; padding: 0 20px;
        }
        input { 
            padding: 15px; font-size: 18px; border: 1px solid #8a7c5d; 
            background: rgba(255,255,255,0.03); color: #ddd; margin-bottom: 30px; 
            outline: none; border-radius: 50px; text-align: center; width: 220px;
            backdrop-filter: blur(5px); transition: all 0.3s;
        }
        input:focus { background: rgba(255,255,255,0.08); border-color: #d4af37; }
        
        #recipient-display {
            display: none; color: #fff; font-size: 2rem; margin-bottom: 40px;
            font-family: 'Times New Roman', serif; text-shadow: 0 0 15px rgba(212,175,55,0.5);
            border-bottom: 1px solid rgba(212,175,55,0.3); padding-bottom: 10px;
        }
        button { 
            padding: 15px 50px; font-size: 18px; 
            background: linear-gradient(135deg, #c5a059 0%, #e6c86e 100%); 
            border: none; cursor: pointer; color: #2b1d0e; font-weight: bold; letter-spacing: 1px;
            border-radius: 50px; transition: transform 0.2s, box-shadow 0.2s; 
            box-shadow: 0 0 20px rgba(197, 160, 89, 0.3);
        }
        button:hover { transform: scale(1.03); box-shadow: 0 0 30px rgba(197, 160, 89, 0.5); }

        /* === 4. ÊªöÂä®ÊèêÁ§∫ === */
        #scroll-hint {
            position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); font-size: 30px; z-index: 10; opacity: 0;
            animation: bounce 3s infinite; pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
        }
        #scroll-hint span { font-size: 12px; margin-bottom: 5px; letter-spacing: 3px; white-space: nowrap;}
        @keyframes bounce { 0%, 100% {transform:translateX(-50%) translateY(0); opacity: 0.3;} 50% {transform:translateX(-50%) translateY(-10px); opacity: 0.8;} }

        /* === 5. ÊñáÂ≠óÂä®Áîª === */
        #intro-text { position: fixed; top: 45%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; pointer-events: none; opacity: 0; z-index: 10; }
        .gold-text { 
            font-size: 3.5rem; font-weight: bold; 
            background: linear-gradient(to bottom, #fff 30%, #f0e68c 100%); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; 
            filter: drop-shadow(0px 0px 15px rgba(240, 230, 140, 0.5)); 
        }

        #scroll-container { height: 600vh; } 

        /* === 6. UI ÊéßÂà∂Âå∫ (ÊâãÊú∫ÈÄÇÈÖç‰ºòÂåñ) === */
        #ui-controls { 
            position: fixed; bottom: 20px; right: 20px; z-index: 20; 
            display: none; animation: fadeIn 1s; flex-direction: column; gap: 10px; align-items: flex-end;
        }
        .action-btn {
            background: rgba(30, 30, 30, 0.7); border: 1px solid #666; color: #ccc;
            padding: 10px 20px; cursor: pointer; border-radius: 30px; 
            font-size: 13px; display: flex; align-items: center; gap: 8px;
            transition: all 0.3s; width: fit-content; backdrop-filter: blur(5px);
        }
        .action-btn:hover { background: #d4af37; color: #000; border-color: #d4af37; }
        .save-btn { border-color: #2ecc71; color: #2ecc71; }
        .save-btn:hover { background: #2ecc71; color: #fff; }

        /* === 7. Áõ∏ÂÜå UI (ÊâãÊú∫Áº©Â∞è) === */
        #album-frame {
            position: fixed; top: 20px; left: 20px; width: 280px;
            background: rgba(30, 20, 15, 0.85); 
            border: 1px solid #5d4037; border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 20; opacity: 0; pointer-events: none; transition: opacity 0.8s;
            display: flex; flex-direction: column; align-items: center; padding: 15px;
            backdrop-filter: blur(10px);
        }
        #album-header { 
            width: 100%; text-align: center; color: #bcaaa4; font-size: 12px; margin-bottom: 12px; 
            font-family: 'Times New Roman', serif; letter-spacing: 2px;
        }
        #album-grid { 
            display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; 
            gap: 6px; width: 100%; aspect-ratio: 1/1; 
        }
        .album-slot { 
            background: rgba(255,255,255,0.05); border: 1px solid #3e2723; border-radius: 3px;
            position: relative; overflow: hidden; cursor: pointer; 
            transition: transform 0.3s, border-color 0.3s; 
            display: flex; justify-content: center; align-items: center;
        }
        .album-slot:hover { transform: scale(1.05); border-color: #a1887f; z-index: 5; }
        .album-slot img { width: 100%; height: 100%; object-fit: cover; display: none; }
        #album-controls { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-top: 15px; color: #8d6e63; font-size: 12px; }
        .nav-btn { background: transparent; border: 1px solid #5d4037; color: #a1887f; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; transition: all 0.2s; }
        .nav-btn:hover { background: #a1887f; color: #1a0f0a; }

        /* === 8. Èü≥‰πêÊí≠ÊîæÂô® === */
        #music-container {
            position: fixed; top: 20px; right: 20px; z-index: 50;
            display: flex; flex-direction: column; align-items: center; gap: 10px;
            opacity: 0; pointer-events: none; transition: opacity 0.8s;
        }
        #vinyl-record {
            width: 45px; height: 45px; border-radius: 50%;
            background: repeating-radial-gradient(#1a1a1a 0, #1a1a1a 2px, #2a2a2a 3px, #2a2a2a 4px);
            border: 1px solid #888; box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
            cursor: pointer; position: relative; transition: transform 0.3s;
        }
        #vinyl-record:hover { transform: scale(1.1); border-color: #fff; }
        .spinning { animation: spin 5s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* Modal */
        #image-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 200; display: none; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.3s; }
        #modal-img { max-width: 90%; max-height: 90%; border: 5px solid #fff; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #close-btn { position: absolute; top: 30px; right: 40px; color: #ccc; font-size: 50px; cursor: pointer; opacity: 0.6; transition: opacity 0.3s; }
        #close-btn:hover { opacity: 1; color: #fff; }

        @media (max-width: 768px) { 
            .gold-text { font-size: 2.5rem; } 
            #album-frame { transform: scale(0.7); transform-origin: top left; left: 10px; top: 10px; }
            #music-container { transform: scale(0.8); transform-origin: top right; right: 10px; top: 10px; }
            #landing-title { font-size: 1.4rem; padding: 0 10px; }
        }
    </style>
</head>
<body>

    <div id="fixed-background"></div>
    <canvas id="bg-canvas"></canvas>

    <div id="landing-page">
        <h2 id="landing-title">WHO IS YOUR BLESSING FOR?</h2>
        <input type="text" id="username-input" placeholder="Enter Name">
        <div id="recipient-display"></div>
        <button id="start-btn" onclick="startJourney()">START JOURNEY</button>
    </div>

    <div id="intro-text">
        <div class="gold-text" style="font-family: 'Times New Roman', serif;">Merry Christmas</div>
        <div class="gold-text" id="display-name" style="font-size: 3rem; margin-top: 20px; color: #f0f0f0; text-shadow: 0 0 10px rgba(255,255,255,0.3);"></div>
    </div>

    <div id="scroll-hint">
        <span>SCROLL / SWIPE</span>
        ‚¨á
    </div>

    <div id="scroll-container"></div>

    <div id="ui-controls">
        <label class="action-btn">
            üì∑ ÊåÇÁÖßÁâá (Upload)
            <input type="file" id="file-input" accept="image/*" onchange="uploadLocalPhoto(this)" style="display:none">
        </label>
        <button class="action-btn save-btn" onclick="exportHTML()">
            üéÅ ÁîüÊàêÊé•ÂäõÊñá‰ª∂ (Share)
        </button>
    </div>

    <div id="album-frame">
        <div id="album-header">OUR MEMORIES</div>
        <div id="album-grid">
            <div class="album-slot" id="slot-0"><img src=""></div>
            <div class="album-slot" id="slot-1"><img src=""></div>
            <div class="album-slot" id="slot-2"><img src=""></div>
            <div class="album-slot" id="slot-3"><img src=""></div>
        </div>
        <div id="album-controls">
            <button class="nav-btn" id="prev-btn" onclick="changeAlbumPage(-1)">&lt;</button>
            <span id="page-indicator">1 / 1</span>
            <button class="nav-btn" id="next-btn" onclick="changeAlbumPage(1)">&gt;</button>
        </div>
    </div>

    <div id="music-container">
        <div id="vinyl-record" onclick="toggleMusic()" title="Play/Pause"></div>
        <label class="action-btn" style="font-size: 10px; padding: 6px 12px; margin-top: 8px; border:none; background: rgba(255,255,255,0.05);">
            üéµ BGM
            <input type="file" id="music-input" accept="audio/*" onchange="loadMusic(this)" style="display:none;">
        </label>
    </div>
    <audio id="bgm" loop></audio>

    <div id="image-modal" onclick="closeModal()">
        <span id="close-btn">&times;</span>
        <img id="modal-img" src="" alt="Full View">
    </div>

    <script id="shared-data" type="application/json">{"photos": [], "music": null, "name": null}</script>

<script>
    // === 1. 2D ËÉåÊôØ (‰ªÖÊòüÊòü) ===
    const bgCanvas = document.getElementById('bg-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    let bgStars = []; const numBgStars = 200;

    function initBackground() {
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;
        bgStars = [];
        for (let i = 0; i < numBgStars; i++) {
            bgStars.push({
                x: Math.random() * bgCanvas.width,
                y: Math.random() * bgCanvas.height,
                radius: Math.random() * 1.5,
                alpha: Math.random(),
                phase: Math.random() * Math.PI * 2
            });
        }
    }

    function animateBackground() {
        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        for (const p of bgStars) {
            p.phase += 0.005;
            const flicker = 0.5 + Math.sin(p.phase) * 0.3;
            bgCtx.beginPath();
            bgCtx.fillStyle = `rgba(255, 255, 255, ${p.alpha * flicker})`;
            bgCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            bgCtx.fill();
        }
        requestAnimationFrame(animateBackground);
    }
    window.addEventListener('resize', initBackground);
    initBackground(); animateBackground();


    // === 2. Three.js Ê†∏ÂøÉÈÄªËæë ===
    let scene, camera, renderer, particles, particleGeo, controls, particleGroup, secretMesh, starMesh;
    let snowSystem, snowGeo; 
    let groundMesh, backlightMesh; 
    
    // Âà§Êñ≠ÁßªÂä®Á´Ø
    const isMobile = window.innerWidth < 768;
    const particleCount = isMobile ? 30000 : 70000; 
    let currentScrollProgress = 0;

    const initialPos = []; const treePos = []; const colors = []; const sizes = [];
    let isTreeFormed = false;
    
    const savedData = { photos: [], music: null, name: null };
    const photoPositions = []; const photoMeshes = []; const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
    let isPlaying = false; const audioEl = document.getElementById('bgm'); const vinylEl = document.getElementById('vinyl-record');
    
    let currentAlbumPage = 0; const itemsPerPage = 4;
    const camStart = { x: 0, y: -25, z: 45 }; 
    const camEnd = { x: 0, y: 0, z: 22 };

    window.onload = function() {
        // ÁßªÂä®Á´Ø‰ºòÂåñÔºöÁº©Áü≠ÊªöÂä®Ë∑ùÁ¶ªÔºåËÆ©Ê†ëÊõ¥ÂÆπÊòìÊàêÂûã
        if (isMobile) {
            document.getElementById('scroll-container').style.height = '350vh';
        }

        try {
            const sharedJson = document.getElementById('shared-data').textContent;
            const data = JSON.parse(sharedJson);
            if (data.photos && Array.isArray(data.photos)) savedData.photos = data.photos;
            if (data.music) { savedData.music = data.music; audioEl.src = data.music; }
            if (data.name) { savedData.name = data.name; }

            if (savedData.name) {
                document.getElementById('username-input').style.display = 'none'; 
                document.getElementById('landing-title').innerText = "A CHRISTMAS GIFT FOR YOU"; 
                const recipientDisplay = document.getElementById('recipient-display');
                recipientDisplay.innerText = "To: " + savedData.name; recipientDisplay.style.display = 'block';
                document.getElementById('start-btn').innerText = "OPEN GIFT"; 
            }
        } catch (e) { console.log("New session."); }
        updateAlbumUI();
    };

    function startJourney() {
        let name;
        if (savedData.name) name = savedData.name;
        else {
            name = document.getElementById('username-input').value || "My Friend";
            savedData.name = name; 
        }
        document.getElementById('display-name').innerText = name;
        
        const landing = document.getElementById('landing-page');
        landing.style.opacity = 0;
        setTimeout(() => { landing.style.display = 'none'; }, 1500);
        
        if (audioEl.src) {
            audioEl.play().then(() => { isPlaying = true; vinylEl.classList.add('spinning'); }).catch(() => {});
        }

        initThree();
        
        const tl = gsap.timeline();
        tl.to("#intro-text", { opacity: 1, duration: 2, delay: 0.5 }) 
          .to("#intro-text", { opacity: 0, duration: 1.5, delay: 2.5 })
          .to("#scroll-hint", { opacity: 1, duration: 1 });
    }

    function compressImage(imgSrc, maxWidth, quality, callback) {
        const img = new Image(); img.src = imgSrc;
        img.onload = () => {
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            let width = img.width; let height = img.height;
            if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; }
            canvas.width = width; canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            const compressedData = canvas.toDataURL('image/jpeg', quality);
            callback(compressedData);
        };
    }

    function createGlowTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)'); 
        gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.3)'); 
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
    }

    function createGroundTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.15)'); 
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)'); 
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); 
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, 128, 128);
        return new THREE.CanvasTexture(canvas);
    }

    function createBacklightTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
        gradient.addColorStop(0, 'rgba(255, 220, 180, 0.2)'); 
        gradient.addColorStop(0.6, 'rgba(100, 150, 200, 0.05)'); 
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, 256, 256);
        return new THREE.CanvasTexture(canvas);
    }

    function initThree() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a1015, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(camStart.x, camStart.y, camStart.z);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.enableZoom = false; controls.enablePan = false; 
        
        // ÂÖ≥ÈîÆÔºö‰∏∫‰∫Ü‰∏çÂπ≤Êâ∞ÊâãÊú∫ÊªöÂä®ÔºåÊàë‰ª¨ÂèØ‰ª•ÈôêÂà∂ÂûÇÁõ¥ÊóãËΩ¨ÔºåÊàñËÄÖ‰æùËµñ CSS touch-action
        // ËøôÈáå‰æùËµñ CSS touch-action: pan-yÔºåËøôÊòØÊúÄÁ®≥Â¶•ÁöÑÊñπÊ°à
        controls.target.set(0, 5, 0);

        window.addEventListener('click', onMouseClick);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onWindowResize);

        createGround();
        createBacklight();

        particleGroup = new THREE.Group();
        scene.add(particleGroup);

        particleGeo = new THREE.BufferGeometry();
        const colorObj = new THREE.Color();

        for (let i = 0; i < particleCount; i++) {
            const rInit = 30 + Math.random() * 80; 
            const thetaInit = Math.random() * Math.PI * 2;
            const phiInit = (Math.random() - 0.5) * Math.PI;
            initialPos.push(rInit * Math.cos(thetaInit), rInit * Math.sin(phiInit) - 20, rInit * Math.sin(thetaInit));
            
            const progress = i / particleCount;
            const y = (progress * 19) - 8; 
            const maxRadiusAtY = (1 - progress) * 9.5; 
            const rRandom = Math.sqrt(Math.random()); 
            const r = maxRadiusAtY * (0.3 + 0.7 * rRandom); 
            const angleBase = progress * Math.PI * 25; 
            const angleOffset = Math.random() * Math.PI * 2; 
            const finalAngle = (r > maxRadiusAtY * 0.8) ? (angleBase + (Math.random()-0.5)) : angleOffset;
            const x = Math.cos(finalAngle) * r;
            const z = Math.sin(finalAngle) * r;
            treePos.push(x, y, z);
            
            const randomVal = Math.random();
            let size = 0.12;
            const distRatio = r / maxRadiusAtY;

            if (randomVal > 0.97) { 
                const decoRand = Math.random();
                if(decoRand > 0.7) colorObj.setHex(0xd65656); 
                else if(decoRand > 0.4) colorObj.setHex(0xe6c25e); 
                else if(decoRand > 0.2) colorObj.setHex(0x5f8aa8); 
                else colorObj.setHex(0xc77d96); 
                size = 0.3; 
                const pushOut = maxRadiusAtY * 1.02;
                treePos[treePos.length-3] = Math.cos(angleBase) * pushOut;
                treePos[treePos.length-1] = Math.sin(angleBase) * pushOut;
            } else if (distRatio > 0.85) {
                 colorObj.setHex(0x6b8e23); 
                 size = 0.15;
            } else if (distRatio < 0.4) {
                colorObj.setHex(0x0a1f10); 
                size = 0.22; 
            } else {
                colorObj.setHex(0x1a5228); 
            }
            
            if(isMobile) size *= 1.8;
            colors.push(colorObj.r, colorObj.g, colorObj.b);
            sizes.push(size);
        }
        
        particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(initialPos, 3));
        particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        particleGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); 
        
        const material = new THREE.PointsMaterial({ 
            size: 0.2, map: createGlowTexture(), transparent: true, opacity: 0.8, 
            vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false 
        });
        particles = new THREE.Points(particleGeo, material);
        particleGroup.add(particles);

        initSnow();
        createBallTopper();
        createSecretMessage(); 
        restorePhotos();

        gsap.registerPlugin(ScrollTrigger); 
        
        gsap.to({ val: 0 }, {
            val: 1, 
            scrollTrigger: { 
                trigger: "#scroll-container", start: "top top", end: "bottom bottom", scrub: 1.5, 
                onUpdate: self => {
                    if (self.progress > 0.05) { gsap.to("#scroll-hint", {opacity: 0}); }
                    if(self.progress > 0.95) {
                        document.getElementById('ui-controls').style.display = 'flex'; 
                        document.getElementById('music-container').style.opacity = '1'; document.getElementById('music-container').style.pointerEvents = 'auto'; 
                        document.getElementById('album-frame').style.opacity = '1'; document.getElementById('album-frame').style.pointerEvents = 'auto'; 
                        isTreeFormed = true;
                    } else {
                        document.getElementById('ui-controls').style.display = 'none'; 
                        document.getElementById('music-container').style.opacity = '0'; document.getElementById('music-container').style.pointerEvents = 'none'; 
                        document.getElementById('album-frame').style.opacity = '0'; document.getElementById('album-frame').style.pointerEvents = 'none'; 
                        isTreeFormed = false;
                    }
                    currentScrollProgress = self.progress;
                    updateCamera(self.progress);
                    
                    if(groundMesh) groundMesh.material.opacity = Math.max(0, (self.progress - 0.5) * 2);
                    if(backlightMesh) backlightMesh.material.opacity = Math.max(0, (self.progress - 0.5) * 1.5);
                }
            }
        });
        
        updateParticles(0); 
        animate();
    }

    function createGround() {
        const geometry = new THREE.PlaneGeometry(60, 60);
        const material = new THREE.MeshBasicMaterial({ 
            map: createGroundTexture(), transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending 
        });
        groundMesh = new THREE.Mesh(geometry, material);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -8.5; 
        scene.add(groundMesh);
    }

    function createBacklight() {
        const geometry = new THREE.PlaneGeometry(100, 100);
        const material = new THREE.MeshBasicMaterial({ 
            map: createBacklightTexture(), transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending 
        });
        backlightMesh = new THREE.Mesh(geometry, material);
        backlightMesh.position.z = -10; 
        backlightMesh.position.y = 5;
        scene.add(backlightMesh);
    }

    function initSnow() {
        const snowCount = isMobile ? 1500 : 3000;
        snowGeo = new THREE.BufferGeometry();
        const snowPos = [];
        const snowVel = []; 
        
        for (let i = 0; i < snowCount; i++) {
            snowPos.push((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 60, (Math.random() - 0.5) * 80);
            snowVel.push((Math.random() - 0.5) * 0.1, Math.random() * 0.1 + 0.05, (Math.random() - 0.5) * 0.1);
        }
        
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
        snowGeo.setAttribute('velocity', new THREE.Float32BufferAttribute(snowVel, 3));
        
        const snowMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.3, map: createGlowTexture(), transparent: true, opacity: 0.8,
            depthWrite: false, blending: THREE.AdditiveBlending
        });
        
        snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);
    }

    function updateSnow() {
        if (!snowSystem) return;
        const positions = snowSystem.geometry.attributes.position.array;
        const velocities = snowSystem.geometry.attributes.velocity.array;
        
        for (let i = 0; i < positions.length; i += 3) {
            positions[i+1] -= velocities[i+1];
            positions[i] += velocities[i] + Math.sin(positions[i+1] * 0.1) * 0.02;
            positions[i+2] += velocities[i+2] + Math.cos(positions[i+1] * 0.1) * 0.02;
            
            if (positions[i+1] < -30) {
                positions[i+1] = 30;
                positions[i] = (Math.random() - 0.5) * 80;
                positions[i+2] = (Math.random() - 0.5) * 80;
            }
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
    }

    function createBallTopper() {
        const geo = new THREE.SphereGeometry(0.6, 32, 32);
        const mat = new THREE.MeshBasicMaterial({ color: 0xfffdf0 });
        starMesh = new THREE.Mesh(geo, mat);
        starMesh.position.set(0, 11.5, 0); 
        starMesh.scale.set(0,0,0); 
        particleGroup.add(starMesh);
        
        const glowGeo = new THREE.PlaneGeometry(6, 6);
        const glowMat = new THREE.MeshBasicMaterial({ 
            map: createGlowTexture(), color: 0xfffdf0, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false 
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        starMesh.add(glow);
    }

    function createSecretMessage() {
        const textCanvas = document.createElement('canvas'); const tCtx = textCanvas.getContext('2d');
        textCanvas.width = 512; textCanvas.height = 128;
        tCtx.font = 'bold 80px Arial'; tCtx.textAlign = 'center'; tCtx.textBaseline = 'middle';
        tCtx.fillStyle = 'white'; tCtx.fillText('I ‚ù§Ô∏è U', textCanvas.width / 2, textCanvas.height / 2);
        let imgData; try { imgData = tCtx.getImageData(0, 0, textCanvas.width, textCanvas.height).data; } catch(e) { return; }
        const textPos = []; const textColors = [];
        for (let y = 0; y < textCanvas.height; y += 2) {
            for (let x = 0; x < textCanvas.width; x += 2) {
                if (imgData[(y * textCanvas.width + x) * 4 + 3] > 128) {
                    const pX = (x - textCanvas.width / 2) * 0.04; const pZ = (y - textCanvas.height / 2) * 0.04;
                    textPos.push(pX, -9.0, pZ); 
                    if (Math.abs(x - textCanvas.width / 2) < 50) textColors.push(1.0, 0.2, 0.4); 
                    else textColors.push(1.0, 1.0, 1.0);
                }
            }
        }
        const textGeo = new THREE.BufferGeometry();
        textGeo.setAttribute('position', new THREE.Float32BufferAttribute(textPos, 3));
        textGeo.setAttribute('color', new THREE.Float32BufferAttribute(textColors, 3));
        const textMaterial = new THREE.PointsMaterial({ size: 0.12, map: createGlowTexture(), transparent: true, opacity: 0, vertexColors: true, blending: THREE.AdditiveBlending, depthTest: false, depthWrite: false }); 
        secretMesh = new THREE.Points(textGeo, textMaterial);
        particleGroup.add(secretMesh);
    }

    function updateAlbumUI() {
        const totalPhotos = savedData.photos.length;
        const totalPages = Math.ceil(totalPhotos / itemsPerPage) || 1;
        if (currentAlbumPage < 0) currentAlbumPage = 0;
        if (currentAlbumPage >= totalPages) currentAlbumPage = totalPages - 1;
        document.getElementById('page-indicator').innerText = `${currentAlbumPage + 1} / ${totalPages}`;
        document.getElementById('prev-btn').disabled = currentAlbumPage === 0;
        document.getElementById('next-btn').disabled = currentAlbumPage === totalPages - 1;
        const startIdx = currentAlbumPage * itemsPerPage;
        for (let i = 0; i < itemsPerPage; i++) {
            const slot = document.getElementById(`slot-${i}`);
            const img = slot.querySelector('img');
            const photoData = savedData.photos[startIdx + i];
            if (photoData) { img.src = photoData.src; img.style.display = 'block'; img.onclick = () => showModal(photoData.src); } else { img.style.display = 'none'; img.onclick = null; }
        }
    }
    function changeAlbumPage(delta) { currentAlbumPage += delta; updateAlbumUI(); }

    function restorePhotos() {
        if (!savedData.photos) return;
        savedData.photos.forEach(item => {
            const img = new Image(); img.src = item.src;
            img.onload = () => {
                const texture = new THREE.Texture(img); texture.needsUpdate = true;
                const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const aspect = img.height / img.width; const geo = new THREE.PlaneGeometry(1.5, 1.5 * aspect);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(item.pos.x, item.pos.y, item.pos.z);
                mesh.lookAt(0, item.lookAt, 0);
                particleGroup.add(mesh); photoMeshes.push(mesh);
                photoPositions.push(new THREE.Vector3(item.pos.x, item.pos.y, item.pos.z));
            };
        });
        updateAlbumUI();
    }

    function uploadLocalPhoto(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function(e) {
                compressImage(e.target.result, 800, 0.7, (compressedSrc) => {
                    const img = new Image(); img.src = compressedSrc;
                    img.onload = () => createPhotoMesh(img, compressedSrc);
                });
            };
            reader.readAsDataURL(input.files[0]);
        } input.value = '';
    }

    function createPhotoMesh(imageElem, base64Data) { 
        const texture = new THREE.Texture(imageElem); texture.needsUpdate = true; 
        const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide }); 
        const aspect = imageElem.height / imageElem.width; const width = 1.8; const height = width * aspect; 
        const geo = new THREE.PlaneGeometry(width, height); const mesh = new THREE.Mesh(geo, mat); 
        let attempts = 0; let foundSlot = false; let positionData = null; 
        while (attempts < 100 && !foundSlot) { 
            attempts++; 
            const randomY = (Math.random() * 16) - 7; 
            const progress = (randomY + 8) / 19; 
            const radiusAtY = (1 - progress) * 9.5; 
            const finalRadius = radiusAtY + 1.2; 
            const randomAngle = Math.random() * Math.PI * 2; 
            const candidatePos = new THREE.Vector3(Math.cos(randomAngle) * finalRadius, randomY, Math.sin(randomAngle) * finalRadius); 
            let isOverlapping = false; const minDistance = width * 1.5; 
            for (const pos of photoPositions) { if (candidatePos.distanceTo(pos) < minDistance) { isOverlapping = true; break; } } 
            if (!isOverlapping) { positionData = { pos: candidatePos, lookAtY: randomY }; photoPositions.push(candidatePos); foundSlot = true; } 
        } 
        if (foundSlot) { 
            mesh.position.copy(positionData.pos); mesh.lookAt(0, positionData.lookAtY, 0); 
            particleGroup.add(mesh); photoMeshes.push(mesh); 
            if (base64Data) { 
                savedData.photos.push({ src: base64Data, pos: {x: positionData.pos.x, y: positionData.pos.y, z: positionData.pos.z}, lookAt: positionData.lookAtY }); 
                currentAlbumPage = Math.ceil(savedData.photos.length / itemsPerPage) - 1; updateAlbumUI();
            }
        } else { alert("Ê†ë‰∏ä‰ΩçÁΩÆÊª°‰∫ÜÔºÅTree is full!"); } 
    }

    function exportHTML() {
        let currentHTML = document.documentElement.outerHTML;
        currentHTML = currentHTML.replace(/<div id="landing-page"[^>]*>/, '<div id="landing-page">');
        const jsonData = JSON.stringify(savedData);
        const regex = /<script id="shared-data" type="application\/json">[\s\S]*?<\/script>/;
        const newScriptContent = `<script id="shared-data" type="application/json">${jsonData}<\/script>`;
        let newHTML = currentHTML.replace(regex, newScriptContent);
        const blob = new Blob([newHTML], {type: 'text/html'}); const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'Our_Christmas_Tree.html'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        alert("Êñá‰ª∂Â∑≤ÁîüÊàêÔºÅ\n\nÂèëÈÄÅÁªôTAÔºåTAÊâìÂºÄÂêéÂ∞±ËÉΩÁúãÂà∞‰Ω†ÁöÑÂêçÂ≠óÂíåÁÖßÁâáÔºÅ");
    }

    function updateParticles(t) {
        if (!particles) return;
        const positions = particles.geometry.attributes.position.array;
        
        const easeT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; 
        const time = Date.now() * 0.001; 

        for (let i = 0; i < particleCount; i++) { 
            const i3 = i * 3;
            const targetX = treePos[i3]; const targetY = treePos[i3+1]; const targetZ = treePos[i3+2];
            const startX = initialPos[i3]; const startY = initialPos[i3+1]; const startZ = initialPos[i3+2];
            
            const floatAmp = (1 - easeT) * 3.0;

            const floatX = Math.sin(time * 3.0 + i * 0.2) * floatAmp;
            const floatY = Math.cos(time * 2.5 + i * 0.15) * floatAmp;
            const floatZ = Math.sin(time * 1.5 + i * 0.3) * floatAmp;
            
            const currentStartX = startX + floatX;
            const currentStartY = startY + floatY;
            const currentStartZ = startZ + floatZ;

            let currX = currentStartX + (targetX - currentStartX) * easeT;
            let currY = currentStartY + (targetY - currentStartY) * easeT;
            let currZ = currentStartZ + (targetZ - currentStartZ) * easeT;
            
            const spinForce = (1 - easeT) * 15.0; 
            const cosA = Math.cos(spinForce); const sinA = Math.sin(spinForce);
            
            positions[i3] = currX * cosA - currZ * sinA;
            positions[i3+1] = currY;
            positions[i3+2] = currX * sinA + currZ * cosA;
        }
        particles.geometry.attributes.position.needsUpdate = true;

        if (starMesh) {
            const starScale = easeT > 0.95 ? (easeT - 0.95) * 20 : 0;
            starMesh.scale.set(starScale, starScale, starScale);
            starMesh.position.y = 11.5 + Math.sin(Date.now() * 0.001) * 0.2;
        }
    }

    function updateCamera(t) {
        camera.position.x = camStart.x + (camEnd.x - camStart.x) * t;
        camera.position.y = camStart.y + (camEnd.y - camStart.y) * t;
        camera.position.z = camStart.z + (camEnd.z - camStart.z) * t;
        camera.lookAt(0, 5, 0); 
        
        if(backlightMesh) backlightMesh.lookAt(camera.position);
    }

    function animate() {
        requestAnimationFrame(animate); 
        if (controls) controls.update();
        if(particleGroup) updateParticles(currentScrollProgress);
        if(snowSystem) updateSnow();
        
        if(particleGroup && isTreeFormed) { 
            particleGroup.rotation.y += 0.002; 
            const sizes = particles.geometry.attributes.size.array;
            for(let i=0; i<particleCount; i+=15) {
                if (Math.random() > 0.98) {
                    const baseSize = isMobile ? 0.2 : 0.15;
                    sizes[i] = baseSize + Math.sin(Date.now() * 0.005 + i) * 0.05;
                }
            }
            particles.geometry.attributes.size.needsUpdate = true;
        }
        
        if (secretMesh && isTreeFormed) {
            const isLookingUnder = camera.position.y < -1;
            const targetOpacity = isLookingUnder ? 1 : 0;
            secretMesh.material.opacity += (targetOpacity - secretMesh.material.opacity) * 0.1;
            if(isLookingUnder) { const pulse = (Math.sin(Date.now() * 0.008) + 1) * 0.5; secretMesh.material.size = 0.12 + pulse * 0.05; }
        } else if(secretMesh) { secretMesh.material.opacity = 0; }
        
        renderer.render(scene, camera);
    }

    function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    function loadMusic(input) { if (input.files && input.files[0]) { const reader = new FileReader(); reader.onload = function(e) { const bgmBase64 = e.target.result; audioEl.src = bgmBase64; savedData.music = bgmBase64; audioEl.play().then(() => { isPlaying = true; vinylEl.classList.add('spinning'); }).catch(e => console.log("Autoplay blocked")); }; reader.readAsDataURL(input.files[0]); } }
    function toggleMusic() { if (!audioEl.src) { alert("ËØ∑ÂÖà‰∏ä‰º†Èü≥‰πêÔºÅ"); return; } if (audioEl.paused) { audioEl.play(); isPlaying = true; vinylEl.classList.add('spinning'); } else { audioEl.pause(); isPlaying = false; vinylEl.classList.remove('spinning'); } }
    function onMouseClick(event) { if (!isTreeFormed) return; mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(photoMeshes); if (intersects.length > 0) showModal(intersects[0].object.material.map.image.src); }
    
    let lastRaycastTime = 0;
    function onMouseMove(event) { 
        if (!isTreeFormed) return; 
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; 
        const now = Date.now();
        if (now - lastRaycastTime > 100) { 
            lastRaycastTime = now; raycaster.setFromCamera(mouse, camera); 
            const intersects = raycaster.intersectObjects(photoMeshes); 
            document.body.style.cursor = intersects.length > 0 ? 'pointer' : 'default'; 
        }
    }
    
    function showModal(src) { const modal = document.getElementById('image-modal'); const img = document.getElementById('modal-img'); img.src = src; modal.style.display = 'flex'; setTimeout(() => modal.style.opacity = 1, 10); }
    function closeModal() { const modal = document.getElementById('image-modal'); modal.style.opacity = 0; setTimeout(() => modal.style.display = 'none', 300); }
</script>
</body>
</html>